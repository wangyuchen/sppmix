#' Plot mixture density.
#'
#' Plot the density surface of a mixture.
#'
#' @param mix An object of class \code{\link{normmix}}.
#' @param lambda intensity for a homogeneous Poisson process.
#' @param win An object of class \code{\link[spatstat]{owin}}.
#' @param L Number of grid on x and y axes.
#' @param truncate Whether the density is truncated in the window (truncate)
#'  or not.
#' @param title1 The title (on top) for the density plot.
#' @param poc The point coodinates for the title. The default is the top middle
#' in the 3-D plot.
#' @param ... Further arguments passed to \code{\link[rgl]{persp3d}}.
#'
#' @export
#' @examples
#' if (require(spatstat)) {
#'   mix1 <- rnormmix(8, .01, 10, square(2), rand_m = TRUE)
#'   plot(mix1, 100, square(2))
#' }
plot.normmix <- function(mix, lambda, win, L = 100,
                         title1="Poisson Process Intensity", truncate = TRUE,
                         pos=c(0,0,0), ...) {
  xcoord <- seq(win$xrange[1], win$xrange[2], length.out = L)
  ycoord <- seq(win$yrange[1], win$yrange[2], length.out = L)

  xlims <- c(win$xrange)
  ylims <- c(win$yrange)

  z <- lambda*dnormmix(mix, win = win, xcoord, ycoord, truncate = truncate)$v

  jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan",
                                   "#7FFF7F", "yellow", "#FF7F00", "red",
                                   "#7F0000"))
  col <- jet.colors(100)[findInterval(z, seq(min(z), max(z), length = 100))]

  zlims=c(0,max(z))

  height = 300
  width = 500

  rgl::open3d(windowRect=c(width/5,
                           height/7,
                           4*width/5,
                           6*height/7),
              zoom=1.2)

  U=rgl::par3d("userMatrix")
  rgl::par3d(userMatrix=
               rgl::rotate3d(U,pi/4,0,0,1))

  rgl::persp3d(x = xcoord, y = ycoord, z = z,
               color = col, xlab="x",ylab="y",zlab="",
               zlim=c(zlims[1]-0.01,zlims[2]),
               box = FALSE, axes = FALSE)
  rgl::axis3d('x')
  rgl::axis3d('y')
  rgl::axis3d('z-+', pos = c(xlims[1], ylims[2], 0))
  rgl::title3d(main = NULL)
  rgl::text3d(xlims[2], ylims[2], zlims[2], texts = title1)
}

Plots_off<- function()
{
  graphics.off()
  while (rgl::rgl.cur()>0)
  {
    rgl::rgl.close()
  }
}

#' Plot spatial point pattern generated from mixture.
#'
#' Plot funciton for spatial point pattern generated from mixture. It's an
#' alternative to spatstat's plotting functions.
#'
#' @param spp A point pattern of class sppmix or \code{\link[spatstat]{ppp}}.
#' @param ... Parameters passed to \code{\link[ggplot2]{ggplot}}.
#'
#' @import ggplot2
#' @export
#' @examples
#' # plot point patterns generated by sppmix
#' mix1 <- rnormmix(3, .01, 5, square(1))
#' spp <- rsppmix(100, mix1, square(1))
#' plot(spp)
#'
#' # plot point patterns generated by spatstat
#' spp <- spatstat::rpoispp(100)
#' plot.spp(spp)
plot.sppmix <- function(spp, ...) {
  df <- as.data.frame(spp)
  p <- ggplot2::ggplot(df, aes(x, y), ...) +
    ggplot2::labs(x = "X", y = "Y",
                  title = paste("Spatial Point Pattern with",
                                nrow(df), "Points")) +
    ggplot2::theme_classic() +
    ggplot2::coord_cartesian(xlim = spp$window$xrange, ylim = spp$window$yrange)
  p + ggplot2::geom_point()
}

#' Plot contour for intensity surface
#'
#' Create a contour plot for the intensity surface with or without realizations
#' on it.
#'
#' @param mix Object of class normmix.
#' @param lambda intensity for a homogeneous Poisson process.
#' @param pattern Object of class \code{\link{ppp}}
#' @param win Object of class \code{\link{owin}}
#' @param L number of grids on each coordinate.  The default is L=100.
#' @param points Logical flag indicating whether plot realizations, i.e.
#' locations, with the contour plot. The default is TRUE.
#' @param filled Logical flag indicating whether plot filled contour plot.
#' The default is TRUE.
#' @param truncate Logical flag indicating whether truncation is used for
#'  \code{pattern}. The default is TRUE.
#' @param ... Further arguments passed to \code{\link[rgl]{filled.contour}}.
#'
#'  @examples
#' # generate a mixture with given ps, mus and sigmas
#' mix1 <- normmix(ps=c(.5, .5),
#'                 mus=list(c(.2, .2), c(.7, .7)),
#'                 sigmas=list(.01*diag(2), .02*diag(2)))
#' # generate a realization from mixture mix1
#' pp1 <- rsppmix(200, mix1, spatstat::square(1))
#' # plot the theoretical intensity surface with a realization
#' plot_contour(mix1,pp1,spatstat::square(1))
#' @export
plot_contour <- function(mix, lambda, pattern, win = Window(pattern), L = 100,
                         points = TRUE, filled = TRUE, truncate = TRUE, ...) {
  xcoord <- seq(win$xrange[1], win$xrange[2], length.out = L)
  ycoord <- seq(win$yrange[1], win$yrange[2], length.out = L)

  surf <- dnormmix(mix, win = win, xcoord, ycoord, truncate = truncate)
  z <- lambda*surf$v
  grid <- expand.grid(xcoord,ycoord)
  temp <- data.frame(grid$Var1,grid$Var2,as.vector(t(z)))
  names(temp) <- c("x","y","z")

  # assign colors to heights for each point
  jet.colors <- grDevices::colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan",
                                              "#7FFF7F", "yellow", "#FF7F00", "red",
                                              "#7F0000"))
  #col <- jet.colors(1000)[findInterval(z$v, seq(min(z$v), max(z$v), length = 1000))]

  #plot(z, col = col)
  if (filled == TRUE){
    if (points == TRUE){
      filled.contour(x=xcoord,y=ycoord, z=t(z),color = jet.colors,
                     plot.axes = { axis(1); axis(2);
                       points(pattern$x, pattern$y,pch = 20) },
                     frame.plot = FALSE,asp = 1 ,axes = TRUE, ... )
    } else {
      filled.contour(x=xcoord,y=ycoord, z=t(z),
                     color = jet.colors,
                     frame.plot = FALSE, asp = 1,axes = TRUE, ...)
    }
  } else {
    m <- ggplot2::ggplot(temp,aes(x, y, z = z)) +
      ggplot2::labs(x = "X", y = "Y",
                    title = paste("Contour of the intensity surface with",
                                  pattern$n, "Points")) +
      ggplot2::stat_contour(aes(colour = ..level..))
    if (points) m <- m + geom_point(data=as.data.frame(pattern),aes(x, y, z=0))
    return(m)
  }
}

#' Plot result from DAMCMC fit
#'
#' @examples
#'
#' fit <- sppmix::est_mix_damcmc(pp = redwood, m = 3, truncate = FALSE,
#'                               L = 5000, burnin = 100, LL = 100)
#' plot(fit)
#' @export
plot.damcmc_res <- function(fit, burnin = length(fit$allgens) / 10) {

  old_par <- getOption("device.ask.default")
  devAskNewPage(ask = TRUE)
  on.exit(devAskNewPage(ask = old_par))


  post_mix <- get_post(fit, burnin = burnin)

  # rgl plots don't wait for ENTER, so it has to appear first
  plot(post_mix$post_normix, post_mix$mean_lambda, Window(fit$data))

  plot_contour(post_mix$post_normix, post_mix$mean_lambda, fit$data)
  print(plot_ind(fit))
  return(invisible())
}
