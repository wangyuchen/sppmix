#' Plot mixture density.
#'
#' Plot the density surface of a mixture.
#'
#' @param mix An object of class \code{\link{normmix}}.
#' @param win An object of class \code{\link[spatstat]{owin}}.
#' @param L Length of grid on x and y axes.
#' @param truncate Whether the density is truncated in the window (truncate)
#'  or not.
#' @param ... Further arguments passed to \code{\link[rgl]{persp3d}}.
#' @export
#' @examples
#' if (require(spatstat)) {
#'   mix1 <- rnormmix(8, .01, 10, square(2), rand_m = T)
#'   plot(mix1, square(2))
#' }
plot.normmix <- function(mix, win, L = 100, truncate = TRUE,
                         title1="Poisson Process Intensity",
                         pos=c(0,0,0), ...) {
  xcoord <- seq(win$xrange[1], win$xrange[2], length.out = L)
  ycoord <- seq(win$yrange[1], win$yrange[2], length.out = L)

  z <- dnormmix(mix, win = win, xcoord, ycoord, truncate = truncate)$v

  jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan",
                                   "#7FFF7F", "yellow", "#FF7F00", "red",
                                   "#7F0000"))
  col <- jet.colors(100)[findInterval(z, seq(min(z), max(z), length = 100))]

  #  title2=as.character(title1)
  #  library(rgl)
  #  rgl::rgl.bringtotop()
  #  rgl::par3d(params=rgl::r3dDefaults)
  #   scr_width <- system("wmic desktopmonitor get screenwidth", intern=TRUE)
  #   scr_height <- system("wmic desktopmonitor get screenheight", intern=TRUE)
  #   height=as.numeric(scr_height[length(scr_height)-1])
  #   width=as.numeric(scr_width[length(scr_width)-1])
  height = 300
  width = 500
  #  height=as.integer(system("wmic desktopmonitor get screenheight"));
  #  width=as.integer(system("wmic desktopmonitor get screenwidth"));
  #  cat(width/2.0)
  rgl::open3d(windowRect=c(width/5,
                           height/7,
                           4*width/5,
                           6*height/7),
              zoom=1.2)
  #rotation about the x-axis, 45 degrees
  #              ,userMatrix =
  #              rgl::rotationMatrix(pi/4,1, 0, 0))
  U=rgl::par3d("userMatrix")
  rgl::par3d(userMatrix=
               rgl::rotate3d(U,pi/4,0,0,1))
  rgl::persp3d(x = xcoord, y = ycoord, z = z,
               color = col, xlab="x",ylab="y",
               zlab="", box = FALSE,
               axes = FALSE)
  rgl::axis3d('x')
  rgl::axis3d('y')
  rgl::axis3d('z-+'#-=low x-coord, +=high y-coord
              ,pos = c(min(xcoord), max(ycoord), 0))
  Rangex=max(xcoord)-min(xcoord);
  Rangey=max(ycoord)-min(ycoord);
  Rangez=max(z)-min(z);
  zmax=max(z)
  #  rgl::observer3d(-xmax, -ymax, zmax,auto = TRUE)
  rgl::title3d(main=NULL)
  rgl::text3d(Rangex/2+pos[1],
              Rangey/2+pos[2],
              zmax+0.1*Rangez,texts=title1)
  #  rgl::text3d(xmax+pos[1],ymax+pos[2],
  #              zmax+pos[3],texts=title1)
  #  rgl::axes3d(edges=c('x','y+','z'),pos=c(0,0,0),box=FALSE)
  #  rgl::axis3d(edge='x',pos=c(0,0,0))
  #  rgl::axis3d(edge='y',pos=c(0,0,0))
  #  rgl::axis3d(edge='z',pos=c(0,0,0))
  #  rgl::decorate3d(main=title1)
}
Plots_off<- function()
{
  graphics.off()
  while (rgl::rgl.cur()>0)
  {
    rgl::rgl.close()
  }
}

#' Plot spatial point pattern generated from mixture.
#'
#' Plot funciton for spatial point pattern generated from mixture. It's an
#' alternative to spatstat's plotting functions.
#'
#' @param spp A point pattern of class sppmix or \code{\link[spatstat]{ppp}}.
#' @param ... Parameters passed to \code{\link[ggplot2]{ggplot}}.
#'
#' @importFrom ggplot2 ggplot aes xlim ylim labs geom_point
#' @export
#' @examples
#' # plot point patterns generated by sppmix
#' mix1 <- rnormmix(3, .01, 5, square(1))
#' spp <- rsppmix(100, mix1, square(1))
#' plot(spp)
#'
#' # plot point patterns generated by spatstat
#' spp <- spatstat::rpoispp(100)
#' plot.spp(spp)
plot.sppmix <- function(spp, ...) {
  df <- as.data.frame(spp)
  p <- ggplot(df, aes(x, y), ...) +
    xlim(spp$window$xrange) + ylim(spp$window$yrange) +
    labs(x = "X", y = "Y",
         title = paste("Spatial Point Pattern with", nrow(df), "Points"))
  p + geom_point()
}

#' @export
plot.dares <- function(dares) {
  plot.ts(dares$ps)
}


#' Plot contour for intensity surface
#'
#' Create a contour plot for the intensity surface with or without realizations
#' on it.
#'
#' @param mix Object of class normmix.
#' @param pattern Object of class \code{\link{ppp}}
#' @param win Object of class \code{\link{owin}}
#' @param L number of grids on each coordinate.  The default is L=100.
#' @param points Logical flag indicating whether plot realizations, i.e.
#' locations, with the contour plot. The default is TRUE.
#' @param truncate Logical flag indicating whether truncation is used for
#'  \code{pattern}. The default is TRUE.
#' @param ... Further arguments passed to \code{\link[rgl]{filled.contour}}.
#'
#'  @export
#'  @examples
#' # generate a mixture with given ps, mus and sigmas
#' mix1 <- normmix(ps=c(.5, .5),
#'                 mus=list(c(.2, .2), c(.7, .7)),
#'                 sigmas=list(.01*diag(2), .02*diag(2)))
#' # generate a realization from mixture mix1
#' pp1 <- rsppmix(200, mix1, spatstat::square(1))
#' # plot the theoretical intensity surface with a realization
#' plot_contour(mix1,pp1,spatstat::square(1))
plot_contour <- function(mix, pattern, win, L = 100,
                         points = TRUE, truncate = TRUE, ...) {
  xcoord <- seq(win$xrange[1], win$xrange[2], length.out = L)
  ycoord <- seq(win$yrange[1], win$yrange[2], length.out = L)

  z <- dnormmix(mix, win = win, xcoord, ycoord, truncate = truncate)$v

  # assign colors to heights for each point
  jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan",
                                   "#7FFF7F", "yellow", "#FF7F00", "red",
                                   "#7F0000"))
  #col <- jet.colors(1000)[findInterval(z$v, seq(min(z$v), max(z$v), length = 1000))]

  #plot(z, col = col)
  if (points == TRUE){
    filled.contour(x=xcoord,y=ycoord, z=t(z),color = jet.colors,
                   plot.axes = { axis(1); axis(2);
                  points(pattern$x, pattern$y,pch = 20) },
                  frame.plot = FALSE,asp = 1 ,axes = TRUE, ... )
  } else {
    filled.contour(x=xcoord,y=ycoord, z=t(z),
                   color = jet.colors,
                   frame.plot = FALSE, asp = 1,axes = TRUE, ...)
  }
}
