#' Plot MCMC chains for mixture mean and probability.
#'
#' Plot MCMC chains generated by \code{\link{est_mix_damcmc}} or
#' \code{\link{est_mix_bdmcmc}}.
#'
#' @inheritParams get_post
#' @param chain Character vector choosing from c("p", "x", "y"). Multiple
#' choices is supported. It will plot MCMC chain for corresponding variables.
#' @param ncol Number of columns in each plot.
#'
#' @export
#'
#' @examples
#' fit <- est_mix_damcmc(pp = redwood, m = 3)
#' plot_chains(fit)
#'
#' # Only plot X and Y
#' plot_chains(fit, chain = c("x", "y"))
plot_chains <- function(fit, burnin = fit$L / 10, chain = c("p", "x", "y"),
                        ncol = fit$m %% 3 + 1) {
  fit <- drop_realization(fit, burnin)
  chain <- match.arg(chain, c("p", "x", "y"), several.ok = TRUE)

  plot_df <- data.frame(comp = gl(fit$m, k = fit$L,
                                  labels = paste("Component", 1:fit$m)),
                        iter = 1:fit$L,
                        ps = as.vector(fit$genps),
                        xs = as.vector(t(fit$genmus[, 1, ])),
                        ys = as.vector(t(fit$genmus[, 1, ])))

  plot_p <- ggplot(plot_df, aes(iter, ps)) + geom_path() +
                     facet_wrap(~ comp, ncol = ncol, scales = "free_y") +
    labs(x = "Iteration", y = "Probability") +
    theme_light() +
    add_title("Generated mixture probabilities", m = fit$m, L = fit$L)

  plot_x <- ggplot(plot_df, aes(iter, xs)) + geom_path() +
    facet_wrap(~ comp, ncol = ncol, scales = "free_y") +
    labs(x = "Iteration", y = expression(mu[x])) +
    theme_light() +
    add_title("Generated mixture mean, X-coordinate", m = fit$m, L = fit$L)

  plot_y <- ggplot(plot_df, aes(iter, ys)) + geom_path() +
    facet_wrap(~ comp, ncol = ncol, scales = "free_y") +
    labs(x = "Iteration", y = expression(mu[y])) +
    theme_light() +
    add_title("Generated mixture mean, Y-coordinate", m = fit$m, L = fit$L)

  lapply(paste0("plot_", chain),
         function(x) print(eval(parse(text = x))))
  invisible(NULL)
}


#' Plot membership indicator
#'
#' @inheritParams get_post
#'
#' @export
#' @examples
#' fit <- est_mix_damcmc(pp = redwood, m = 5)
#' plot_ind(fit)
plot_ind <- function(fit, burnin = fit$L / 10) {
  fit <- drop_realization(fit, burnin)

  probs <- GetAvgLabelsDiscrete2Multinomial_sppmix(fit$genzs, fit$m)
  plot_df <- data.frame(probability = as.vector(probs),
                        point = 1:fit$data$n,
                        component = rep(1:fit$m, each = fit$data$n))

  ggplot(plot_df, aes(point, component - .5, xend = point,
                      yend = component + .5, col = probability)) +
    geom_segment(size = I(5)) +
    coord_cartesian(ylim = c(.5, fit$m + .5)) +
    scale_color_gradient(low = "grey", high = "grey2",
                         guide = guide_colorbar(nbin = 100, barheight = 15)) +
    labs(x = "Point", y = "Component", colour = "Probability") +
    theme_light() +
    add_title("Membership Indicator Plot", m = fit$m, n = fit$data$n)
}





#' Plot the average intensity surface
#'
#' Plot the average of the posterior realizations for the intensity surface
#'
#' @param fit An object contains all posterior realizations from
#' \code{\link{est_mix_damcmc}} or \code{\link{est_mix_bdmcmc}}.
#' @param win An object of class \code{\link[spatstat]{owin}}.
#' @param LL Number of grid on x and y axes.
#' @param burnin Length of burnin, default value is 1/10 of total number of
#' iteration.
#' @param zlims The limits of z axis. The default does not have
#' additional limits on z axis.
#' @author Athanasios Christou Micheas, Jiaxun Chen, Yuchen Wang
#' @export
#' @examples
#' # generate data
#' mix2 <- normmix(ps=c(.4, .6), mus=list(c(0.1, 0.1), c(0.8, 0.8)),
#' sigmas=list(.02*diag(2), .01*diag(2)), 100, square(1))
#' pp2 <- rsppmix(mix2)
#' # Run Data augmentation MCMC and get posterior realizations
#' post=est_mix_damcmc(pp2,L = 5000,2,truncate = F)
#' # Plot the average of realized surfaces
#' plot_avgsurf(fit = post, win = square(1), LL = 30, burnin = 1000)
plot_avgsurf <- function(fit, win = fit$data$window, LL = 100,
                         burnin = length(fit$allgens_List) / 10,
                         zlims = c(0, 0)) {

  # get limits
  xlims <- c(win$xrange)
  ylims <- c(win$yrange)
  L  <-  dim(fit$genps)[1]

  mix_of_postmeans <- MakeMixtureList(fit$allgens_List,burnin)
  mean_lambda <- mean(fit$genlamdas[burnin:L])
  zmax_genmeanmix <- mean_lambda * GetMixtureMaxz_sppmix(mix_of_postmeans,
                                                         LL,xlims,ylims,
                                                         fit$ApproxCompMass)
  #find the highest z
  maxz_height <- max(zmax_genmeanmix)
  if (zlims[1] == 0 && zlims[2] == 0) {
    zlims <- c(0, 1.1*maxz_height)
  }
  gridvals  <-  GetGrid_sppmix(LL,xlims,ylims)
  xcoord <- as.vector(gridvals[[1]])
  ycoord <- as.vector(gridvals[[2]])
  zcoord <- ApproxAvgPostIntensity(
    fit$allgens_List, fit$genlamdas, LL, burnin,
    xlims, ylims, fit$ApproxCompMass)
  title1 = paste("Average of",L-burnin,
                 "posterior realizations of the intensity function")
  jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan",
                                   "#7FFF7F", "yellow", "#FF7F00", "red",
                                   "#7F0000"))
  col <- jet.colors(100)[findInterval(zcoord, seq(min(zcoord), max(zcoord),
                                                  length = 100))]

  rgl::layout3d(matrix(1:2, 1, 2), widths = c(5, 1))
  rgl::open3d(windowRect = c(0, 45, 612, 657), zoom=1.2)

  U=rgl::par3d("userMatrix")
  rgl::par3d(userMatrix=
               rgl::rotate3d(U,pi/4,0,0,1))
  zmax=max(zcoord)
  Rangez=zmax-min(zcoord);
  rgl::persp3d(x = xcoord, y = ycoord, z = zcoord,
               color = col, xlab="x",ylab="y",zlab="",
               zlim=c(zlims[1]-0.01,zlims[2]),
               box = FALSE, axes = FALSE)
  rgl::axis3d('x')
  rgl::axis3d('y')
  rgl::axis3d('z-+', pos = c(xlims[1], ylims[2], 0))
  rgl::title3d(main=NULL)
  rgl::text3d(xlims[2],ylims[2],
              zlims[2]
              ,texts= title1)
  rgl::bgplot3d(suppressWarnings(
    fields::image.plot(legend.only = TRUE,
                       # smallplot= c(.8,.82,0.05,.7),
                       zlim = zlims,
                       col = jet.colors(100))))
}



#' Plot result from DAMCMC fit
#'
#' @inheritParams get_post
#' @examples
#' fit <- est_mix_damcmc(pp = redwood, m = 5)
#' plot(fit)
#' @export
plot.damcmc_res <- function(fit, burnin = length(fit$allgens) / 10) {
  old_par <- getOption("device.ask.default")
  devAskNewPage(ask = TRUE)
  on.exit(devAskNewPage(ask = old_par))

  post_mix <- get_post(fit, burnin = burnin)

  # rgl plots don't wait for ENTER, so it has to appear first
  plot(post_mix)

  print(plotmix_2d(post_mix, pattern = fit$data))
  print(plot_ind(fit, burnin))
  plot_chains(fit, burnin)
  invisible(NULL)
}


#' Plot the average surfaces from BDMCMC fit
#'
#' @inheritParams get_post
#' @param LL Number of grid on x and y axes.
#' @param zlims The limits of z axis. The default does not have
#' additional limits on z axis.
#' @examples
#' fit <- est_mix_bdmcmc(pp = redwood, m = 5)
#' plot(fit)
#' @export
plot.bdmcmc_res <- function(fit, win = fit$data$window,
                            burnin = length(fit$allgens)/10,
                            LL = 100, zlims = c(0, 0)) {
  L <- length(fit$genlamdas)
  xlims <- win$xrange
  ylims <- win$yrange


  distr_numcomp <- GetCompDistr_sppmix(fit$numcomp[-(1:burnin)],fit$maxnumcomp)
  zcoord <- ApproxBayesianModelAvgIntensity_sppmix(
    fit$allgens_List[-(1:burnin)],
    fit$genlamdas[-(1:burnin)],
    fit$numcomp[-(1:burnin)],
    distr_numcomp,1,fit$maxnumcomp,LL, xlims, ylims,
    fit$ApproxCompMass[-(1:burnin),])
  #find the highest z
  maxz_height <- max(zcoord)
  if (zlims[1] == 0 && zlims[2] == 0) {
    zlims <- c(0, 1.1*maxz_height)
  }

  gridvals <- GetGrid_sppmix(LL, xlims, ylims)
  xcoord <- as.vector(gridvals[[1]])
  ycoord <- as.vector(gridvals[[2]])
  title1 = paste("Bayesian model average of",L-burnin,"posterior realizations")
  jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan",
                                   "#7FFF7F", "yellow", "#FF7F00", "red",
                                   "#7F0000"))
  col <- jet.colors(100)[findInterval(zcoord, seq(min(zcoord), max(zcoord),
                                                  length = 100))]


  rgl::layout3d(matrix(1:2, 1, 2), widths = c(5, 1))
  rgl::open3d(windowRect = c(0, 45, 612, 657), zoom=1.2)

  U=rgl::par3d("userMatrix")
  rgl::par3d(userMatrix=
               rgl::rotate3d(U,pi/4,0,0,1))
  zmax=max(zcoord)
  Rangez=zmax-min(zcoord);
  rgl::persp3d(x = xcoord, y = ycoord, z = zcoord,
               color = col, xlab="x",ylab="y",zlab="",
               zlim=c(zlims[1]-0.01,zlims[2]),
               box = FALSE, axes = FALSE)
  rgl::axis3d('x')
  rgl::axis3d('y')
  rgl::axis3d('z-+', pos = c(xlims[1], ylims[2], 0))
  rgl::title3d(main=NULL)
  rgl::text3d(xlims[2],ylims[2],
              zlims[2]
              ,texts= title1)
  rgl::bgplot3d(suppressWarnings(
    fields::image.plot(legend.only = TRUE,
                       # smallplot= c(.8,.82,0.05,.7),
                       zlim = zlims,
                       col = jet.colors(100))))
}


#' @export
Plots_off<- function()
{
  graphics.off()
  while (rgl::rgl.cur()>0)
  {
    rgl::rgl.close()
  }
}
