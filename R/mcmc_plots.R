#' Plot MCMC chains for mus and ps
#'
#' Plot MCMC chains generated by \code{\link{est_mix_damcmc}}
#' @inheritParams plot_avgsurf
#' @author Athanasios Christou Micheas, Jiaxun Chen, Yuchen Wang
#' @export
#' @examples
#' # generate data
#' mix2 <- normmix(ps=c(.4, .6), mus=list(c(0.1, 0.1), c(0.8, 0.8)),
#' sigmas=list(.02*diag(2), .01*diag(2)))
#' pp2 <- rsppmix(100,mix2,square(1))
#' # Run Data augmentation MCMC and get posterior realizations
#' post=est_mix_damcmc(pp2,L = 5000,2,truncate = F)
#' # plot MCMC chains for parameter mus and ps
#' plot_chains(post)

plot_chains <- function(fit, burnin = length(fit$allgens_List) / 10) {
    L=length(fit$allgens_List)
    genps = fit$genps[(burnin + 1):L, ]
    genmus = fit$genmus[, , (burnin + 1):L]
    m = dim(fit$genmus)[1]
  plot(genps[,1], xlab = "Iteration", ylab = "p",
       type = "l",main =
         "Generated mixture probabilities\nComponent 1")
  for (i in 2:m) {
    plot(genps[,i], xlab = "Iteration", ylab = "p",
         type = "l",main =
           paste("Generated mixture probabilities\nComponent",i))
  }

  plot(genmus[1,1,],xlab = "Iteration",ylab = bquote(mu),
       type = "l", main =
         "Generated mixture means\nComponent 1, x-coord")
  plot(genmus[1,2,], xlab = "Iteration", ylab =bquote(mu),
       type = "l",main =
         "Generated mixture means\nComponent 1, y-coord")

  for (i in 2:m) {
    plot(genmus[i,1,], xlab = "Iteration", ylab = bquote(mu),
         type = "l", main =
           paste("Generated mixture means\nComponent"
                 ,i,", x-coord"))
    plot(genmus[i,2,], xlab = "Iteration", ylab =
           bquote(mu), type = "l", main =
           paste("Generated mixture means\nComponent"
                 ,i,", y-coord"))
  }

}


#' Plot membership indicator
#'
#' @inheritParams plot_avgsurf
#' @author Yuchen Wang, Jiaxun Chen
#'
#' @export
#' @examples
#' fit <- sppmix::est_mix_damcmc(pp = redwood, m = 3, truncate = FALSE,
#'                               L = 50000, LL = 100)
#' plot_ind(fit)

plot_ind <- function(fit, burnin = length(fit$allgens_List) / 10) {
  m <- dim(fit$genmus)[1]
  L <- length(fit$allgens_List)
  zs <- GetAvgLabelsDiscrete2Multinomial_sppmix(fit$genzs[(burnin + 1):L, ], m)
  plot_df <- tidyr::gather(data.frame(zs, point = 1:nrow(zs)),
                           comp, probability, -point)
  names(plot_df)[3]="Probability"
  plot_df$component <- as.integer(gsub("X", "", plot_df$comp))# - 0.5

  ggplot2::qplot(point, component, data = plot_df, geom = "segment",
                 col = Probability, xend = point, yend = component+.5 ,
                 y=component-.5 ) +
    ggplot2::scale_color_gradient(low = "white", high = "black") +
    #    ggplot2::coord_cartesian(ylim = c(.5, m + .5), xlim = c(0, nrow(zs) + 1)) +
    ggplot2::theme_classic() +
    ggplot2::theme(panel.border = ggplot2::element_rect(fill = NA, size = 1)) +
    ggplot2::ylim(.5, m+.5) +
    #    ggplot2::annotate("text", x = 2:3, y = 20:21, label = c("my label", "label 2"))+
    #    ggplot2::xlim(.5,nrow(zs)+.5) +
    ggplot2::scale_x_discrete(
      #      limits=c(1,nrow(zs)),
      breaks=seq(1,nrow(zs),length=5)
      ,labels=waiver()
    )+
    ggplot2::coord_cartesian(xlim = c(-5, nrow(zs)+5 )) +
    ggplot2::xlab("Point")+
    ggplot2::ylab("Component")+
    ggplot2::ggtitle("Membership indicators")
}





#' Plot the average intensity surface
#'
#' Plot the average of the posterior realizations for the intensity surface
#'
#' @param fit An object contains all posterior realizations from
#' \code{\link{est_mix_damcmc}} or \code{\link{est_mix_bdmcmc}}.
#' @param win An object of class \code{\link[spatstat]{owin}}.
#' @param LL Number of grid on x and y axes.
#' @param burnin Length of burnin, default value is 1/10 of total number of
#' iteration.
#' @param zlims The limits of z axis. The default does not has
#' additional limits on z axis.
#' @author Athanasios Christou Micheas, Jiaxun Chen, Yuchen Wang
#' @export
#' @examples
#' # generate data
#' mix2 <- normmix(ps=c(.4, .6), mus=list(c(0.1, 0.1), c(0.8, 0.8)),
#' sigmas=list(.02*diag(2), .01*diag(2)))
#' pp2 <- rsppmix(100,mix2,square(1))
#' # Run Data augmentation MCMC and get posterior realizations
#' post=est_mix_damcmc(pp2,L = 5000,2,truncate = F)
#' # Plot the average of realized surfaces
#' plot_avgsurf(fit = post, win = square(1), LL = 30, burnin = 1000)
plot_avgsurf <- function(fit, win, LL = 30,
                         burnin = length(fit$allgens_List) / 10,
                         zlims = c(0, 0)) {

  # get limits
  xlims <- c(win$xrange)
  ylims <- c(win$yrange)
  L  <-  dim(fit$genps)[1]

  mix_of_postmeans <- MakeMixtureList(fit$allgens_List,burnin)
  mean_lambda <- mean(fit$genlamdas[burnin:L])
  zmax_genmeanmix <- mean_lambda * GetMixtureMaxz_sppmix(mix_of_postmeans,
                                                         LL,xlims,ylims)
  #find the highest z
  maxz_height <- max(zmax_genmeanmix)
  if (zlims[1] == 0 && zlims[2] == 0) {
    zlims <- c(0, 1.1*maxz_height)
  }
  gridvals  <-  GetGrid_sppmix(LL,xlims,ylims)
  xcoord <- as.vector(gridvals[[1]])
  ycoord <- as.vector(gridvals[[2]])
  zcoord <- ApproxAvgPostIntensity(
    fit$allgens_List, fit$genlamdas, LL, burnin,
    xlims, ylims)
  title1 = paste("Average of",L-burnin,
                 "posterior realizations of the intensity function")
  jet.colors <- colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan",
                                   "#7FFF7F", "yellow", "#FF7F00", "red",
                                   "#7F0000"))
  col <- jet.colors(100)[findInterval(zcoord, seq(min(zcoord), max(zcoord),
                                                  length = 100))]

  #   if(.Platform$OS.type=='windows')
  #   {
  #     scr_width <- system("wmic desktopmonitor get screenwidth", intern=TRUE)
  #     scr_height <- system("wmic desktopmonitor get screenheight", intern=TRUE)
  #     height=as.numeric(scr_height[length(scr_height)-1])
  #     width=as.numeric(scr_width[length(scr_width)-1])
  #   }

  #  rgl::layout3d(matrix(1:2, 1, 2), widths = c(5, 1))
  rgl::open3d(windowRect = c(0, 45, 612, 657), zoom=1.2)

  U=rgl::par3d("userMatrix")
  rgl::par3d(userMatrix=
               rgl::rotate3d(U,pi/4,0,0,1))
  zmax=max(zcoord)
  Rangez=zmax-min(zcoord);
  rgl::persp3d(x = xcoord, y = ycoord, z = zcoord,
               color = col, xlab="x",ylab="y",zlab="",
               zlim=c(zlims[1]-0.01,zlims[2]),
               box = FALSE, axes = FALSE)
  rgl::axis3d('x')
  rgl::axis3d('y')
  rgl::axis3d('z-+', pos = c(xlims[1], ylims[2], 0))
  rgl::title3d(main=NULL)
  rgl::text3d(xlims[2],ylims[2],
              zlims[2]
              ,texts= title1)
  rgl::bgplot3d(suppressWarnings(
    fields::image.plot(legend.only = TRUE,
                       smallplot= c(.8,.82,0.05,.7),
                       zlim = zlims,
                       col = jet.colors(100))))
}



#' Plot result from DAMCMC fit
#'
#' @examples
#'
#' fit <- sppmix::est_mix_damcmc(pp = redwood, m = 3, truncate = FALSE,
#'                               L = 5000, LL = 100)
#' plot(fit)
#' @export
plot.damcmc_res <- function(fit, burnin = length(fit$allgens) / 10) {
  old_par <- getOption("device.ask.default")
  devAskNewPage(ask = TRUE)
  on.exit(devAskNewPage(ask = old_par))


  post_mix <- get_post(fit, burnin = burnin)

  # rgl plots don't wait for ENTER, so it has to appear first
  plot(post_mix, Window(fit$data))

  plot_contour(post_mix, fit$data)
  print(plot_ind(fit, burnin))
  plot_chains(fit, burnin)
  return(invisible())
}


#' @export
Plots_off<- function()
{
  graphics.off()
  while (rgl::rgl.cur()>0)
  {
    rgl::rgl.close()
  }
}
